% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/brm_archetype_successive_cells.R
\name{brm_archetype_successive_cells}
\alias{brm_archetype_successive_cells}
\title{Cell-means-like successive differences archetype}
\usage{
brm_archetype_successive_cells(
  data,
  covariates = TRUE,
  prefix_interest = "x_",
  prefix_nuisance = "nuisance_",
  baseline = !is.null(attr(data, "brm_baseline")),
  baseline_subgroup = !is.null(attr(data, "brm_baseline")) && !is.null(attr(data,
    "brm_subgroup")),
  baseline_subgroup_time = !is.null(attr(data, "brm_baseline")) && !is.null(attr(data,
    "brm_subgroup")),
  baseline_time = !is.null(attr(data, "brm_baseline"))
)
}
\arguments{
\item{data}{A classed data frame from \code{\link[=brm_data]{brm_data()}}.}

\item{covariates}{Logical of length 1.
\code{TRUE} (default) to include any additive covariates declared with
the \code{covariates} argument of \code{\link[=brm_data]{brm_data()}},
\code{FALSE} to omit.
For informative prior archetypes, this option is set in
functions like \code{\link[=brm_archetype_successive_cells]{brm_archetype_successive_cells()}} rather than in
\code{\link[=brm_formula]{brm_formula()}} in order to make sure columns are appropriately
centered and the underlying model matrix has full rank.}

\item{prefix_interest}{Character string to prepend to the new columns
of generated fixed effects of interest (relating to group, subgroup,
and/or time).
In rare cases, you may need to set a non-default prefix to prevent
name conflicts with existing columns in the data, or rename
the columns in your data.
\code{prefix_interest} must not be the same value as \code{prefix_nuisance}.}

\item{prefix_nuisance}{Same as \code{prefix_interest}, but relating to
generated fixed effects NOT of interest (not relating to group,
subgroup, or time). Must not be the same value as \code{prefix_interest}.}

\item{baseline}{Logical of length 1.
\code{TRUE} to include an additive effect for baseline
response, \code{FALSE} to omit.
Default is \code{TRUE} if \code{\link[=brm_data]{brm_data()}} previously declared a baseline
variable in the dataset.
For informative prior archetypes, this option is set in
functions like \code{\link[=brm_archetype_successive_cells]{brm_archetype_successive_cells()}} rather than in
\code{\link[=brm_formula]{brm_formula()}} in order to make sure columns are appropriately
centered and the underlying model matrix has full rank.}

\item{baseline_subgroup}{Logical of length 1.}

\item{baseline_subgroup_time}{Logical of length 1.
\code{TRUE} to include baseline-by-subgroup-by-time interaction,
\code{FALSE} to omit.
Default is \code{TRUE} if \code{\link[=brm_data]{brm_data()}} previously declared baseline
and subgroup variables in the dataset.
For informative prior archetypes, this option is set in
functions like \code{\link[=brm_archetype_successive_cells]{brm_archetype_successive_cells()}} rather than in
\code{\link[=brm_formula]{brm_formula()}} in order to make sure columns are appropriately
centered and the underlying model matrix has full rank.}

\item{baseline_time}{Logical of length 1.
\code{TRUE} to include baseline-by-time interaction, \code{FALSE} to omit.
Default is \code{TRUE} if \code{\link[=brm_data]{brm_data()}} previously declared a baseline
variable in the dataset.
For informative prior archetypes, this option is set in
functions like \code{\link[=brm_archetype_successive_cells]{brm_archetype_successive_cells()}} rather than in
\code{\link[=brm_formula]{brm_formula()}} in order to make sure columns are appropriately
centered and the underlying model matrix has full rank.}
}
\value{
A special classed \code{tibble} with data tailored to
the successive differences archetype. The dataset is augmented with
extra columns with the \code{"archetype_"} prefix, as well as special
attributes to tell downstream functions like \code{\link[=brm_formula]{brm_formula()}} what to
do with the object.
}
\description{
Create an informative prior archetype where the fixed effects
are successive differences between adjacent time points.
}
\details{
In this parameterization, each fixed effect is either an intercept
on the first time point or the difference between two adjacent time
points, and each treatment group has its own set of fixed effects
independent of the other treatment groups.

To illustrate, suppose the dataset has two treatment groups A and B,
time points 1, 2, and 3, and no other covariates.
Let \code{mu_gt} be the conditional expectation of the response at group
\code{g} time \code{t} given data and hyperparameters. Then, the cell-means-like
successive differences parameterization declares model coefficients
\code{beta_1}, \code{beta_2}, ... \code{beta_6} as follows:

\if{html}{\out{<div class="sourceCode">}}\preformatted{  `mu_A1 = beta_1`
  `mu_A2 = beta_1 + beta_2`
  `mu_A3 = beta_1 + beta_2 + beta_3`

  `mu_B1 = beta_4`
  `mu_B2 = beta_4 + beta_5`
  `mu_B3 = beta_4 + beta_5 + beta_6`
}\if{html}{\out{</div>}}

For group A, \code{beta_1} is the time 1 intercept, \code{beta_2} represents
time 2 minus time 1, and \code{beta_3} represents time 3 minus time 2.
\code{beta_4}, \code{beta_5}, and \code{beta_6} represent the analogous roles.
}
\section{Nuisance variables in informative prior archetypes}{

In the presence of covariate adjustment, functions like
\code{\link[=brm_archetype_successive_cells]{brm_archetype_successive_cells()}} convert nuisance factors into binary
dummy variables, then center all those dummy variables and any
continuous nuisance variables at their means in the data.
This ensures that the main model coefficients
of interest are not implicitly conditional on a subset of the data.
In other words, preprocessing nuisance variables this way preserves
the interpretations of the fixed effects of interest, and it ensures
informative priors can be specified correctly.
}

\examples{
if (identical(Sys.getenv("BRM_EXAMPLES", unset = ""), "true")) {
set.seed(0L)
data <- brm_simulate_outline(
  n_group = 2,
  n_patient = 100,
  n_time = 4,
  rate_dropout = 0,
  rate_lapse = 0
) |>
  dplyr::mutate(response = rnorm(n = dplyr::n())) |>
  brm_data_change() |>
  brm_simulate_continuous(names = c("biomarker1", "biomarker2")) |>
  brm_simulate_categorical(
    names = c("status1", "status2"),
    levels = c("present", "absent")
  )
dplyr::select(
  data,
  group,
  time,
  patient,
  starts_with("biomarker"),
  starts_with("status")
)
brm_archetype_successive_cells(data)
}
}
\concept{informative prior archetypes}
